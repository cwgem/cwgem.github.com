MacBook Pro Retina Secure Workstation Guide
===========================================
:Author: Chris White
:Email: <cwprogram@live.com>
:Date: 2013-04-24

== Introduction ==

A work in progress guide for encrypted root (lvm/cryptosetup) MacBook Pro Retina install with grsecurity patched kernel. The following are primary sources utilized while making this guide:

* http://en.gentoo-wiki.com/wiki/Apple_Macbook_Pro[Apple Macbook Pro]
* http://www.gentoo.org/doc/en/handbook/handbook-amd64.xml[Gentoo AMD64 Handbook]
* http://en.gentoo-wiki.com/wiki/Root_filesystem_over_LVM2,_DM-Crypt_and_RAID[Root filesystem over LVM2, DM-Crypt and RAID]
* http://wiki.gentoo.org/wiki/Apple_Macbook_Pro_Retina[Apple Macbook Pro Retina]

Thank you to all the authors who worked on these guides and allowed me to consolidate the information into a guide format. 

== Partitioning ==

So first off a bit of partitioning needs to happen. Here is the layout I originally had after tearing my hear out a bunch of times:

[source,text]
----
Number  Start   End    Size    File system  Name                  Flags
 1      20.5kB  210MB  210MB   fat32        EFI system partition  boot
 2      210MB   125GB  125GB                Macintosh HD
 3      125GB   126GB  650MB   hfs+         Recovery HD
 5      426GB   426GB  300MB   ext2
 6      426GB   500GB  74.1GB
----

So time to cleanup. First order of business is to remove the messed up partitions to regain free space:

[source,text]
----
(parted) rm 5                                                             
(parted) rm 6                                                             
(parted) print                                                            
Model: ATA APPLE SSD SM512E (scsi)
Disk /dev/sda: 500GB
Sector size (logical/physical): 512B/4096B
Partition Table: gpt
Disk Flags: 

Number  Start   End    Size   File system  Name                  Flags
 1      20.5kB  210MB  210MB  fat32        EFI system partition  boot
 2      210MB   125GB  125GB               Macintosh HD
 3      125GB   126GB  650MB  hfs+         Recovery HD
----

Okay, now to create the `/boot` partition which will be unencrypted and ext2 so grub can read it and load files importantly. Since it will be MB in size first I change the units:

[source,text]
----
(parted) unit MB                                                          
(parted) print                                                            
Model: ATA APPLE SSD SM512E (scsi)
Disk /dev/sda: 500278MB
Sector size (logical/physical): 512B/4096B
Partition Table: gpt
Disk Flags: 

Number  Start     End       Size      File system  Name                  Flags
 1      0.02MB    210MB     210MB     fat32        EFI system partition  boot
 2      210MB     125240MB  125030MB               Macintosh HD
 3      125240MB  125890MB  650MB     hfs+         Recovery HD
----

Now to make a 300MB partition for `/boot` to live in:

[source,text]
----
(parted) mkpart primary 125890MB 126190MB                                         
(parted) print                                                            
Model: ATA APPLE SSD SM512E (scsi)
Disk /dev/sda: 500278MB
Sector size (logical/physical): 512B/4096B
Partition Table: gpt
Disk Flags: 

Number  Start     End       Size      File system  Name                  Flags
 1      0.02MB    210MB     210MB     fat32        EFI system partition  boot
 2      210MB     125240MB  125030MB               Macintosh HD
 3      125240MB  125890MB  650MB     hfs+         Recovery HD
 4      125890MB  126190MB  300MB                  primary
----

The value `125890MB` I got by looking at the end of the previous partition and using that as a start point. `300` was added to that to give me the end point of `126190MB`. Next is the space for the rest of the partition. This is going to be managed through LVM so it can just take up the rest of the space:

[source,text]
----
(parted) mkpart primary 126190MB -1                              
(parted) print                                                            
Model: ATA APPLE SSD SM512E (scsi)
Disk /dev/sda: 500278MB
Sector size (logical/physical): 512B/4096B
Partition Table: gpt
Disk Flags: 

Number  Start     End       Size      File system  Name                  Flags
 1      0.02MB    210MB     210MB     fat32        EFI system partition  boot
 2      210MB     125240MB  125030MB               Macintosh HD
 3      125240MB  125890MB  650MB     hfs+         Recovery HD
 4      125890MB  126190MB  300MB                  primary
 5      126190MB  500277MB  374087MB               primary
----

The start value is the same logic as when setting up `/boot`. `-1` indicates that this partition should use the rest of the disk. Now to display the units in GB for easier viewing:

[source,text]
----
(parted) unit GB                                                          
(parted) print                                                            
Model: ATA APPLE SSD SM512E (scsi)
Disk /dev/sda: 500GB
Sector size (logical/physical): 512B/4096B
Partition Table: gpt
Disk Flags: 

Number  Start   End     Size    File system  Name                  Flags
 1      0.00GB  0.21GB  0.21GB  fat32        EFI system partition  boot
 2      0.21GB  125GB   125GB                Macintosh HD
 3      125GB   126GB   0.65GB  hfs+         Recovery HD
 4      126GB   126GB   0.30GB               primary
 5      126GB   500GB   374GB                primary
----

So we end up with a 300MB `/boot` and a 374GB partition to use for LVM setup. Now it's time for formatting. First off the `/boot` partition needs to be formatted ext2. First quit parted to write the partitions:

[source,text]
----
(parted) quit
----

Now the actual formatting:

[source,text]
----
# mkfs.ext2 /dev/sda4
----

== Crypto Setup ==

Now to prepare the setup for crypto work. First off is clearing off data from the disk:

[source,text]
----
# dd if=/dev/zero of=/dev/sda5 bs=100M
----

You can also use `/dev/urandom` for improved security, but it could possibly take around a few hours due to the fact that a random number has to be generated when polling it. This `/dev/zero` run took around 20 minutes to complete. Now for the actual crypto setup:

[source,text]
----
# cryptsetup -y --cipher aes-cbc-essiv:sha256 --key-size 256 luksFormat /dev/sda5 

WARNING!
========
This will overwrite data on /dev/sda5 irrevocably.

Are you sure? (Type uppercase yes): YES
Enter LUKS passphrase: 
Verify passphrase:
----

This sets up encryption with a pass-phrase for the main encryption process. Now we need to map it to an unencrypted form that can be used for LVM setup:

[source,text]
----
# cryptsetup luksOpen /dev/sda5 encrypt
Enter passphrase for /dev/sda5:
----

This gives us a `/dev/mapper/encrypt` device to work with for the LVM setup.

== LVM ==

Now for the LVM part. First we create a physical volume, which takes the partition and makes it workable with LVM's more flexible volume layout system:

[source,text]
----
# pvcreate /dev/mapper/encrypt 
  Physical volume "/dev/mapper/encrypt" successfully created
----

Now for a volume group, which works to make physical volumes to logical volumes (the actual mount points we want):

[source,text]
----
# vgcreate crypt /dev/mapper/encrypt 
  Volume group "crypt" successfully created
----

Now for the actual layouts. First some swap which I'll just set as 5GB:

[source,text]
----
# lvcreate -L5G -nswap crypt
  Logical volume "swap" created
----

The `-nswap` part is just a name for it. This ends up as a `/dev/mapper/crypt-swap` device node (volumegroup-logicalvolumename is the general format). Next is the root node, which I just use the rest of the partition for. If this was an actual server I'd probably break out various `/var/` directories to prevent log DoS (Denial of Service). However this is a workstation so I'll just leave it be as remaining space:

[source,text]
----
# lvcreate -l100%FREE -nroot crypt
  Logical volume "root" created
----

Okay and now for the formatting. I tend to choose ext4 as my default so that gets formatted first:

[source,text]
----
# mkfs.ext4 /dev/mapper/crypt-root 
mke2fs 1.42 (29-Nov-2011)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
22511616 inodes, 90017792 blocks
4500889 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=4294967296
2748 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks: 
        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 
        4096000, 7962624, 11239424, 20480000, 23887872, 71663616, 78675968

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (32768 blocks): done
Writing superblocks and filesystem accounting information: done
----

Next is swap, enabling it once finished:

[source,text]
----
# mkswap /dev/mapper/crypt-swap && swapon /dev/mapper/crypt-swap
----

Finally some size sanity checking by temporary mounting:

[source,text]
----
# free   
             total       used       free     shared    buffers     cached
Mem:      16336048     146872   16189176          0       8896      45364
-/+ buffers/cache:      92612   16243436
Swap:      5242876          0    5242876
----

Swap checks out okay.

[source,text]
----
# df -h
Filesystem              Size  Used Avail Use% Mounted on
...
/dev/mapper/crypt-root  338G   67M  321G   1% /mnt/gentoo
----

And so does the root mount.

== Stages ==

The stage I use is the hardened stage, which has already been pre-compiled with the hardened toolchain. It can be found on http://www.gentoo.org/main/en/mirrors2.xml[one of the mirrors] under the directory `/releases/amd64/current-stage3/hardened/`. Now to download it to the chroot directory:

[source,text]
----
# cd /mnt/gentoo
# wget http://gentoo.mirrors.pair.com/releases/amd64/current-stage3/hardened/20130418/stage3-amd64-hardened-20130418.tar.bz2
----

Just to be safe, verify the SHA hash of the tarball:

[source,text]
----
# wget http://gentoo.mirrors.pair.com/releases/amd64/current-stage3/hardened/20130418/stage3-amd64-hardened-20130418.tar.bz2.DIGESTS.asc
# openssl dgst -r -sha512 stage3-amd64-hardened-20130418.tar.bz2
55c3483d1a9b86ed5805bbc44ee15274b6a57269a4bc9229b11017f6525d6ffdc6c8ee6b8c151ccb63c1a482e3f73a8d0dea10c9a5300786f0d20b347206588c *stage3-amd64-hardened-20130418.tar.bz2
# cat stage3-amd64-hardened-20130418.tar.bz2.DIGESTS.asc
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

# SHA512 HASH
55c3483d1a9b86ed5805bbc44ee15274b6a57269a4bc9229b11017f6525d6ffdc6c8ee6b8c151ccb63c1a482e3f73a8d0dea10c9a5300786f0d20b347206588c  stage3-amd64-hardened-20130418.tar.bz2
....
----

Everything checks out there so time to extract the tarball. Be sure to use the exact options for extraction so the tarball ends up with proper permissions:

[source,text]
----
# tar xvjpf stage3-*.tar.bz2
----

== chroot Prep ==

Now it's time to edit the `make.conf` file. This can be done with:

[source,text]
----
# nano -w /mnt/gentoo/etc/portage/make.conf
----

[WARNING]
Beware, the location changed! Older Gentoo versions had it in `/etc/make.conf`

My `/etc/portage/make.conf` ended up looking like this (comments inline explaining):

[source,text]
----
# Only thing really different from the default is the 
# -march=corei7 bit
CFLAGS="-O2 -march=corei7 -pipe"
CXXFLAGS="${CFLAGS}"
CHOST="x86_64-pc-linux-gnu"

# I decided to keep with the latest version of 
# stuff a lot, so I'm going with the unstable
# keyword route. For a *production* workstation 
# this should be deleted to maintain stable
# keywords.
ACCEPT_KEYWORDS="~amd64"

# smp - Multi core support
# fuse - Good for tools like encfs
# xinerama - For *painless* dual monitor setups
# alsa - Alsa sound support
# Everything else is customized stuff that may or may not apply to you
# Most of the gnome related stuff will come from the profile
USE="gstreamer erlang ruby smp ffmpeg theora vpx vim-syntax cjk -sdl fuse xinerama alsa"

# Weeee Core i7
MAKEOPTS="-j8"

# This is for a custom profile that mixes hardened with gnome 
PORTDIR_OVERLAY="/usr/local/portage"

GENTOO_MIRRORS="http://gentoo.mirrors.tds.net/gentoo http://gentoo.osuosl.org/ http://gentoo.mirrors.pair.com/"
SYNC="rsync://rsync.us.gentoo.org/gentoo-portage"

# synaptics is for the touchpad
INPUT_DEVICES="evdev keyboard mouse synaptics"

# You'll want this so grub knows how to deal with the EFI partition
# and setup a bootable system properly
GRUB_PLATFORMS="efi-64"

# I study Japanese so...
LINGUAS="ja en"
----

A note on USE flags is that I tend to use `/etc/portage/package.use` a lot more than IUSE, as most changes I want to keep specific to a package. Next is to copy over `/etc/resolv.conf` settings to the chroot so it knows where google.com and what not are:

[source,text]
----
# cp -L /etc/resolv.conf /mnt/gentoo/etc/
----

Finally there is setting up some system directories for the chroot by linking them with the host system:

[source,text]
----
# mount -t proc none /mnt/gentoo/proc
# mount --rbind /sys /mnt/gentoo/sys
# mount --rbind /dev /mnt/gentoo/dev
----

== chroot and Portage Setup ==

Time to enter the chroot. A custom PS1 is added so it's easy to tell which is the host and which is the chroot:

[source,text]
----
# chroot /mnt/gentoo /bin/bash
# source /etc/profile
# export PS1="(chroot) $PS1"
----

A portage tree is kind of a nice thing to have. I tend to stick with web-rsync for stable which doesn't change much, but since this is unstable I'll go ahead and sync to the absolute latest version of the tree (well, outside of CVS):

[source,text]
----
# mkdir /usr/portage
# emerge-webrsync # This creates a faster start point for emerge --sync
# emerge --sync
----

The next step is the profile which is usually straightforward. However due to the fact that there isn't a combined hardened / gnome official profile, it will be necessary to create a custom one. First is creating the `PORTDIR_OVERLAY` directory structure:

[source,text]
----
# mkdir -p /usr/local/portage/profiles/hardened-gnome
# cd /usr/local/portage
----

First is the repository name, which isn't *really* necessary, but it does make annoying warnings go away:

[source,text]
----
# echo 'hardened-gnome' > profiles/repo_name
----

The use case for this is generally telling apart the main upstream portage repository from a local repository in terms of managing packages. Next is the list of architectures that this profile can support. As this an AMD64 system I'll just leave it as amd64 only:

[source,text]
----
# echo 'amd64' > profiles/hardened-gnome/arch.list
----

Now profiles are cascading in nature, so creating a hardened gnome profile is as simple as pointing to the respective profile locations:

[source,text]
----
# nano -w profiles/hardened-gnome/parent

../../../../portage/profiles/targets/desktop/gnome
../../../../portage/profiles/hardened/linux/amd64
----

The profile locations are pointed to using relative directory traversal. Now to set this as the main profile:

[source,text]
----
# rm /etc/portage/make.profile && ln -s /usr/local/portage/profiles/hardened-gnome /etc/portage/make.profile
----

Just to make sure it worked properly, a test emerge:

[source,text]
----
# emerge -pv nano

These are the packages that would be merged, in order:

Calculating dependencies... done!
[ebuild     U  ] app-editors/nano-2.3.2 [2.3.1-r2] USE="justify magic ncurses nls spell* unicode -debug -minimal -slang" 1,686 kB
----

Okay so everything looks good there. Now on to the kernel.

== Kernel ==

Before getting started, the timezone needs to be set so `uname` doesn't show weird output. I'm in Pacific Time so I set it up as follows:

[source,text]
----
# cp /usr/share/zoneinfo/America/Los_Angeles /etc/localtime
# echo 'America/Los_Angeles' > /etc/timezone
----

Everyone's favorite part of the setup: the kernel. This will section will focus on the kernel via specific parts necessary for the various hardware components of the MacBook Pro Retina as well a necessary for encrypted root. First off is getting the kernel sources. Gentoo has a Grsecurity patched kernel all setup that can be emerged:

[source,text]
----
# emerge sys-kernel/hardened-sources
----

To get something annoying out of the way ahead of time, `udev` will cry unless this is enabled:

[source,text]
----
Device Drivers  --->
  Generic Driver Options  --->
    [*] Maintain a devtmpfs filesystem to mount at /dev
----

Now then to continue I used a patch that supports https://gist.github.com/cwgem/5464697[various CPU mtune options for modern processors]. It was ported from https://github.com/graysky2/kernel_gcc_patch[this repository]. An easy patching method is to download it to root and apply it from within the source tree:

[source,text]
----
# wget https://gist.github.com/cwgem/5464697/raw/8624f6874f6d60c269b98a3b1fd35cea6cc83da9/gistfile1.txt -O kernel-3.8.8-gcc-cpu-additions.patch
# cd /usr/src/linux-3.8.8-hardened/
# patch -i ~/kernel-3.8.8-gcc-cpu-additions.patch -p1
----

Now for the actual kernel setup. The `make menuconfig` option is used here to make things as easy as possible:

[source,text]
----
# make menuconfig
----

=== CPU Selection ===

First is the selection of processor features:

[source,text]
----
Processor type and features  --->
  Processor family (Generic-x86-64)  --->
    (X) Intel Core i7
----

If you don't feel like applying the above patch, there is an `Intel Core 2` option that can be used instead. 

=== Filesystem ===

For this I build in ext2 (for boot) and ext4 (for root). Other filesystems are built in as modules:

[source,text]
----
File systems  --->
  <*> Second extended fs support
    [*]   Ext2 extended attributes
    [*]     Ext2 POSIX Access Control Lists
    [*]     Ext2 Security Labels
    [ ]   Ext2 execute in place support (NEW)
  <M> Ext3 journalling file system support
    [*]   Default to 'data=ordered' in ext3 (NEW)
    [*]   Ext3 extended attributes (NEW)
    [*]     Ext3 POSIX Access Control Lists
    [*]     Ext3 Security Labels
  <*> The Extended 4 (ext4) filesystem
    [*]   Use ext4 for ext2/ext3 file systems (NEW)
    [*]   Ext4 POSIX Access Control Lists
    [*]   Ext4 Security Labels
    [ ]   EXT4 debugging support (NEW)
    [ ] JBD2 (ext4) debugging support (NEW)
  <M> Reiserfs support
    [ ]   Enable reiserfs debug mode (NEW)
    [ ]   Stats in /proc/fs/reiserfs (NEW)
    [ ]   ReiserFS extended attributes (NEW)
  <M> JFS filesystem support
    [*]   JFS POSIX Access Control Lists
    [*]   JFS Security Labels
    [ ]   JFS debugging (NEW)
    [ ]   JFS statistics (NEW)
  <M> XFS filesystem support
    [ ]   XFS Quota support (NEW)
    [*]   XFS POSIX ACL support
    [ ]   XFS Realtime subvolume support (NEW)
    [ ]   XFS Debugging support (EXPERIMENTAL) (NEW)
  < > GFS2 file system support
  <M> Btrfs filesystem (EXPERIMENTAL) Unstable disk format
    [*]   Btrfs POSIX Access Control Lists
    [ ]   Btrfs with integrity check tool compiled in (DANGEROUS) (NEW)
----

Note that in all of the filesystems `POSIX Access Control Lists` and `Security Labels` were selected where applicable. This allows `paxctl` to have a dedicated place for setting various attributes for objects that don't work well with the various enforcement features that PaX offers.

=== LVM Support (with crypt) ===

[source,text]
----
Device Drivers  --->
  [*] Multiple devices driver support (RAID and LVM)  --->
    <*>   Device mapper support
      [ ]     Device mapper debugging support (NEW)
      <*>     Crypt target support
----

All the required options were already selected for LVM. The only change that needed to be made here was enabling `Crypt target support`

=== Cryptography ===

In this case I build them all in out of laziness. It makes it much easier when working with cryptosetup. You may wish to build them all as modules and load them in instead:

[source,text]
----
-*- Cryptographic API  --->
  *** Digest ***
  -*-   CRC32c CRC algorithm
  <*>   CRC32c INTEL hardware acceleration
  <*>   GHASH digest algorithm
  <*>   MD4 digest algorithm
  -*-   MD5 digest algorithm
  <*>   Michael MIC keyed digest algorithm
  <*>   RIPEMD-128 digest algorithm
<snip>
  -*-   Twofish cipher algorithm (x86_64)
  -*-   Twofish cipher algorithm (x86_64, 3-way parallel)
  <*>   Twofish cipher algorithm (x86_64/AVX)               
----

So in essence, everything under `*** Digest ***` and `*** Ciphers ***` is enabled.

=== lspci Check ===

Now time to look at the hardware components:

[source,text]
----
00:00.0 Host bridge: Intel Corporation 3rd Gen Core processor DRAM Controller (rev 09)
00:01.0 PCI bridge: Intel Corporation Xeon E3-1200 v2/3rd Gen Core processor PCI Express Root Port (rev 09)
00:01.1 PCI bridge: Intel Corporation Xeon E3-1200 v2/3rd Gen Core processor PCI Express Root Port (rev 09)
00:01.2 PCI bridge: Intel Corporation Xeon E3-1200 v2/3rd Gen Core processor PCI Express Root Port (rev 09)
00:02.0 VGA compatible controller: Intel Corporation 3rd Gen Core processor Graphics Controller (rev 09)
00:14.0 USB controller: Intel Corporation 7 Series/C210 Series Chipset Family USB xHCI Host Controller (rev 04)
00:16.0 Communication controller: Intel Corporation 7 Series/C210 Series Chipset Family MEI Controller #1 (rev 04)
00:1a.0 USB controller: Intel Corporation 7 Series/C210 Series Chipset Family USB Enhanced Host Controller #2 (rev 04)
00:1b.0 Audio device: Intel Corporation 7 Series/C210 Series Chipset Family High Definition Audio Controller (rev 04)
00:1c.0 PCI bridge: Intel Corporation 7 Series/C210 Series Chipset Family PCI Express Root Port 1 (rev c4)
00:1c.1 PCI bridge: Intel Corporation 7 Series/C210 Series Chipset Family PCI Express Root Port 2 (rev c4)
00:1d.0 USB controller: Intel Corporation 7 Series/C210 Series Chipset Family USB Enhanced Host Controller #1 (rev 04)
00:1f.0 ISA bridge: Intel Corporation HM77 Express Chipset LPC Controller (rev 04)
00:1f.2 SATA controller: Intel Corporation 7 Series Chipset Family 6-port SATA Controller [AHCI mode] (rev 04)
00:1f.3 SMBus: Intel Corporation 7 Series/C210 Series Chipset Family SMBus Controller (rev 04)
01:00.0 VGA compatible controller: NVIDIA Corporation GK107M [GeForce GT 650M Mac Edition] (rev a1)
01:00.1 Audio device: NVIDIA Corporation GK107 HDMI Audio Controller (rev a1)
03:00.0 Ethernet controller: Broadcom Corporation Device 16a3 (rev 10)
03:00.1 SD Host controller: Broadcom Corporation NetXtreme BCM57765 Memory Card Reader (rev 10)
04:00.0 Network controller: Broadcom Corporation BCM4331 802.11a/b/g/n (rev 02)
----

So things to check on here:

1. Wireless
2. SATA support (otherwise nasty kernel panics happen)
3. USB Support
4. Graphics Support
5. Audio Support
6. Memory card support
7. Touchpad support
8. Keyboard backlight support
9. Webcam support

==== Wireless ====

This is actually a fairly complicated part unless you've done it enough. The newer MacBook Pro Retinas have a newer Broadcom chip that's a bit interesting in getting to work. So pay attention here as all of these are very important and lack of them may cause you endless frustration. First off is enabling the B43 driver:

[source,text]
----
Device Drivers  --->
  [*] Network device support  --->
    [*]   Wireless LAN (NEW)  --->
      <M>   Broadcom 43xx wireless support (mac80211 stack)
      [ ]     Broadcom 43xx PCMCIA device support (NEW)
      [*]   Support for 802.11n (N-PHY) devices (EXPERIMENTAL)
      [*]   Support for low-power (LP-PHY) devices (NEW)
      [*]   Support for HT-PHY (high throughput) devices (EXPERIMENTAL)
----

Here I also disabled all the entries under:

[source,text]
----
Device Drivers  --->
  [*] Network device support  --->
    [*]   Ethernet driver support  --->
----

As I only plan to use wireless for this system. Next is PHY support, enabling the two Broadcom entries as modules:

[source,text]
----
Device Drivers  --->
  [*] Network device support  --->
    <*>   PHY Device support and infrastructure  --->
      <M>   Drivers for Broadcom PHYs
      <M>   Driver for Broadcom BCM8706 and BCM8727 PHYs
----

Next is GPIO support:

[source,text]
----
Device Drivers  --->
  [*] GPIO Support  --->
    <M>   Intel ICH GPIO
----

This will allow necessary GPIO support for the Broadcom AMBA:

[source,text]
----
Device Drivers  --->
  Broadcom specific AMBA  --->
    <M> BCMA support
    [*]   Support for BCMA on PCI-host bus
    [*] BCMA Broadcom GBIT MAC COMMON core driver
    [*] BCMA GPIO driver
    [ ] BCMA debugging (NEW) 
----

This is the last of what needs to be done for wireless to work properly in the kernel. 

==== SATA ====

Nothing needed to be done here, as the appropriate SATA drivers were already enabled.

==== USB Support (Including iSight) ====

Yes the iSight driver is located here. USB 3.0 needs to be enabled as well:

[source,text]
----
Device Drivers  --->
  [*] USB support (NEW)  --->
    <*>   xHCI HCD (USB 3.0) support
    <*>   iSight firmware loading support
----

Also, I use cups for printing support and it will mention:

[source,text]
----
 * Your usb printers will be managed via libusb. In this case, 
 * cups-1.6.2 requires the USB_PRINTER support disabled.
----

So that can be disabled here:

[source,text]
----
Device Drivers  --->
  [*] USB support  --->
    < >   USB Printer support
----

==== Graphics Support ====

Intel graphics is already enabled, but the Nvidia support needs work. First off to enable the open source driver (in a grsecurity patched kernel you really don't want to deal with the closed binary...):

[source,text]
----
Device Drivers  --->
  Graphics support  --->
    <*> Nouveau (nVidia) cards
    (5)   Maximum debug level (NEW)
    (3)   Default debug level (NEW)
    [*]   Support for backlight control (NEW)
----

Next is framebuffer support, where both Nvidia and Intel options get enabled, along with VESA as a fallback:

[source,text]
----
Device Drivers  --->
  Graphics support  --->
    -*- Support for frame buffer devices  --->
      [*]   VESA VGA graphics support
      [*]   EFI-based Framebuffer Support
      < >   N411 Apollo/Hecuba devkit support (NEW)
      < >   Hercules mono graphics support (NEW)
      < >   Epson S1D13XXX framebuffer support (NEW)
      <*>   nVidia Framebuffer Support
      [*]     Enable DDC Support
      [ ]     Lots of debug output (NEW)
      [*]     Support for backlight control (NEW)
      <*>   nVidia Riva support
      [*]     Enable DDC Support
      [ ]     Lots of debug output (NEW)
      [*]     Support for backlight control (NEW)
      <*>   Intel740 support (EXPERIMENTAL)
      <*>   Intel LE80578 (Vermilion) support
      <*>     Intel Carillo Ranch support
----

Finally the backlight driver:

[source,text]
----
Device Drivers  --->
  Graphics support  --->
    --- Backlight & LCD device support
      <*>     Apple Backlight Drive
----

==== Audio Support ====

Nothing to be done here as the correct drivers are already selected. As a side note I removed the PCMCIA and USB audio support as I really don't use those. 

==== Memory Card Support ====

The following option were enable for the SD card reader support:

[source,text]
----
Device Drivers  --->
  <*> MMC/SD/SDIO card support  --->
    <*>   Secure Digital Host Controller Interface support
    <*>   SDHCI support on PCI bus
    [ ]     Ricoh MMC Controller Disabler  (EXPERIMENTAL) (NEW)
    <*>   SDHCI support for ACPI enumerated SDHCI controllers
    <*>   SDHCI platform and OF driver helper
----

==== Touchpad Support ====

This is considered a "mouse" and will need to be enabled:

[source,text]
----
Device Drivers  --->
    Input device support  --->
      [*]   Mice (NEW)  --->
      <*>   Apple USB BCM5974 Multitouch trackpad support
----

==== Keyboard Backlight ====

This also enables a few other Mac specific items:

[source,text]
----
Device Drivers  --->
  -*- Hardware Monitoring support  --->
    <*>   Apple SMC (Motion sensor, light sensor, keyboard backlight)
----

==== Webcam ====

The actual iSight USB part has been enabled, but general media support is still required:

[source,text]
----
Device Drivers  --->
  <*> Multimedia support  --->
    [*]   Cameras/video grabbers support
    [*]   Media USB Adapters  --->
      <*>   USB Video Class (UVC)
      [*]     UVC input events device support (NEW)
----

=== Security ===

Now that the hardware is out of the way it's time for security setup:

[source,text]
----
Security options  ---> 
  [*] Grsecurity
    Configuration Method (Automatic)  ---> 
    Usage Type (Desktop)  --->
    Virtualization Type (None)  --->
    Required Priorities (Performance)  --->
    Default Special Groups  --->
    Customize Configuration  --->
----

Basically automatic configuration is chosen with emphasis on performance and desktop usage. SELinux was also disabled as I plan to use RBAC instead. Also for `sys-auth/consolekit` syscall auditing needs to be enabled:

[source,text]
----
General setup  --->
  [*] Auditing support
  [*]   Enable system-call auditing support
----

=== Building The Kernel ===

First just to be safe after all that work:

[source,text]
----
# cp .config ~/config.back
----

I tend to do the kernel build as a one liner:

[source,text]
----
# make clean && make -j8 && make modules_install && make install
----

The `make clean` ensure the build environment is clean before compiling (no objects laying around). `make -j8` does an 8 job parallel build since this is a corei7 system and I want the build to go quickly. `make modules_install` installs all the modules into `/lib/modules` so they can be loaded properly. Finally, `make install` installs the kernel image to `/boot`.

=== Module Setup ===

The only module I really load is for wifi:

[source,text]
----
# echo 'modules="b43"' >> /etc/conf.d/modules
----

Everything else will get pulled in as part of the module dependency resolution process.

== Basic Configuration ==

=== fstab ===

Now for basic adjustment of config files. To start off there's `/etc/fstab`, which is needed for volumes to mount properly at boot. Since this is LVM, the `/dev/mapper` nodes will be used instead (the exception being the `/boot` partition):

[source,text]
----
# nano -w /etc/fstab

# <fs>                  <mountpoint>    <type>          <opts>          <dump/pass>

# NOTE: If your BOOT partition is ReiserFS, add the notail option to opts.
/dev/sda4               /boot           ext2            noauto,noatime  1 2
/dev/mapper/crypt-root  /               ext4            noatime         0 1
/dev/mapper/crypt-swap  none            swap            sw              0 0
/dev/cdrom              /mnt/cdrom      auto            noauto,ro       0 0
----

=== Hosts ===

Next is the hostname for the system, which is whatever you fancy the system to be named. In this case I went with inferno:

[source,text]
----
# nano -w /etc/conf.d/hostname
# Set to the hostname of this machine
hostname="inferno"
----

I'm using DHCP so setting the domain name is of no concern to me. However it does leave a nasty `(none)` bit at login, so this will get rid of that:

[source,text]
----
# nano -w /etc/issue
 
This is \n (\s \m \r) \t
----

Finally adding the hostname information to `/etc/hosts` so that it resolves properly:

[source,text]
----
# nano -w  /etc/hosts
127.0.0.1       localhost inferno
::1             localhost inferno
----

== System Info ==

First a root password needs to be set:

[source,text]
----
# passwd
New password: 
Retype new password: 
passwd: password updated successfully
----

There's only a slight change to be made here for `/etc/rc.conf`. That is to enable hotplugging of network services, as NetworkManager will be used:

[source,text]
----
# nano -w /etc/rc.conf

<snip>
rc_hotplug="!net.*nano -w /etc/rc.conf"
<snip>
----

The hardware clock needs to be set to local:

[source,text]
----
# nano -w /etc/conf.d/hwclock

<snip>
clock="local"
<snip>
----

Finally is the locales. Most will be okay with just `en_US.UTF-8` and `en_US ISO-8859-1`. However I also happen to work with Japanese files and so forth, so my locale setup ends up like this:

[source,text]
----
# nano -w /etc/locale.gen
en_US ISO-8859-1
en_US.UTF-8 UTF-8
ja_JP.EUC-JP EUC-JP
ja_JP.UTF-8 UTF-8
ja_JP EUC-JP
----

Now to generate the locales:

[source,text]
----
# locale-gen 
 * Generating 5 locales (this might take a while) with 1 jobs
 *  (1/5) Generating en_US.ISO-8859-1 ... [ ok ]
 *  (2/5) Generating en_US.UTF-8 ... [ ok ]
 *  (3/5) Generating ja_JP.EUC-JP ... [ ok ]
 *  (4/5) Generating ja_JP.UTF-8 ... [ ok ]
 *  (5/5) Generating ja_JP.EUC-JP ... [ ok ]
 * Generation complete
----

== Unstable Bootstrap ==

Now, this is an unstable system, and with changes to the profile new keywords have been added. This means the base system isn't quite up to date yet. So to get around this I'm going to do a bit of bootstrapping. The process will basically be:

1. Rebuild system packages - This gives a gcc/glibc which produces optimized code
2. Rebuild system packages again - This builds gcc/glibc itself using the optimized code
3. Rebuild all packages - This rebuilds everything with the new gcc/glibc to be properly optimized

You don't really have to do this, I just like to be thorough. Also note that the new USE flags and system profile will bring in other non-core system packages. That's okay though it's an corei7!

=== Rebuild System Packages ===

First run an `emerge -epv system` to ensure nothing really weird will happen:

[source,text]
----
# emerge -epv system
----

[WARNING]
As of this writing a version of autotools https://bugs.gentoo.org/show_bug.cgi?id=451744[breaks a few builds]. I recommend masking it until that bug is resolved:

[source,text]
----
# mkdir /etc/portage/package.mask
# echo '=sys-devel/automake-1.13.1' >> /etc/portage/package.mask/automake
----

If anything shows up at the bottom that looks unsolvable, best to ask on mailing lists/IRC/forums. Now then grab a nice book or so and fire away if everything looks good:

[source,text]
----
# emerge -e system
----

The kernel ebuild doesn't actually compile the kernel so:

[source,text]
----
# cd /usr/src/linux
# make clean && make -j8 && make modules_install && make install
----

=== Rebuild System Packages Again ===

Another quick check:

[source,text]
----
# emerge -epv system
----

Followed by another rebuild:

[source,text]
----
# emerge -e system
----

And another kernel compile:

[source,text]
----
# cd /usr/src/linux
# make clean && make -j8 && make modules_install && make install
----

=== Rebuild All The Packages ===

Now it's time to compile system again along with all the other packages we want. Recompiling system... well just follow the instructions from the previous section. Now then on to the packages we really want.

==== Wifi ====

There's two main packages needed for wifi to work properly. The first is the firmware that is loaded by the b43 module. First the Broadcom license needs to be accepted for the firmware to be installable. The license can be found here:

[source,text]
----
# nano -w /usr/portage/licenses/Broadcom
----

Assuming you accept the license, the firmware can be installed this way:

[NOTE]
If you don't then you might want to try another broadcom driver, or get a thunderbolt/USB ethernet adapter instead

[source,text]
----
# mkdir /etc/portage/package.license/ && echo '>=sys-firmware/b43-firmware-5.100.138 Broadcom' >> /etc/portage/package.license/broadcom
# emerge sys-firmware/b43-firmware
----

Next is NetworkManager, which I've found to be by far the easiest to manage wireless connections, even on command line:

[source,text]
----
# emerge networkmanager
# rc-update add NetworkManager default
----

==== Terminal Emulator ====

I use tmux for this. Others may prefer screen. I find it an easy way to make sure a lost SSH connection doesn't kill all the things I'm working on:

[source,text]
----
# emerge tmux
----

==== Time Server ====

This makes sure the time sync is okay:

[source,text]
----
# emerge net-misc/ntp
----

Due to the fact that NetworkManager needs to authenticate against an access point, I generally start the service manually at connection:

[source,text]
----
# /etc/init.d/ntpd start
----

==== Syslog ====

Here I use `syslog-ng`:

[source,text]
----
# emerge syslog-ng
# rc-update add syslog-ng default
----

==== Cron ====

For cron I use `cronie` which is different from the `vixie-cron` default. This is mainly because `cronie` has an active upstream and matches most closely with `vixie-cron` functionality:

[source,text]
----
# emerge sys-process/cronie
# rc-udpate add cronie default
----

==== File Indexing ====

`mlocate` is what I use for file indexing:

[source,text]
----
# emerge mlocate
----

==== SSH Access ====

Thankfully the sshd server is already installed, so it's just a matter of starting it at boot:

[source,text]
----
# rc-update add sshd default
----

==== Initrd ====

The initrd file acts as a minimal environment before the main environment loads, letting things like activating LVM volume groups and unlocking the encrypted filesystem happen before the actual boot. Without this the kernel would not be able to boot the root filesystem. So first some packages need to be built with statically. This is needed because `/usr/lib` and the like won't be around in the minimal environment. To build necessary packages statically, the following use flag adjustments are needed:

[source,text]
----
# mkdir /etc/portage/package.use
# nano -w /etc/portage/package.use/static

sys-fs/lvm2 static static-libs
sys-apps/busybox static
sys-fs/cryptsetup static
dev-libs/libgcrypt static-libs
dev-libs/popt static-libs
virtual/udev static-libs
dev-libs/libgpg-error static-libs
sys-libs/e2fsprogs-libs static-libs
sys-apps/util-linux static-libs
sys-fs/udev static-libs
----

Now to emerge the necessary packages:

[source,text]
----
# emerge lvm2 busybox cryptsetup
----

As it hasn't been mentioned, busybox is a minimal shell which is often statically linked to provide rescue shells. Now it's time to create the actual initrd file for the kernel to load. First create a directory for the files to go in:

[source,text]
----
# cd ~/ && mkdir initram && cd initram
----

Now to create the minimal directory structure:

[source,text]
----
# mkdir bin dev dev/mapper dev/vc etc newroot proc sys
----

Next copy over the important static binaries over:

[source,text]
----
# cp /bin/busybox /sbin/cryptsetup /sbin/lvm.static bin
----

Then move over the `lvm.static` file to be just lvm:

[source,text]
----
# mv bin/lvm.static bin/lvm
----

Busybox acts in place of a number of commands, so link these commands to it:

[source,text]
----
# for command in cat mount sh switch_root umount sleep; do ln -s busybox "bin/${command}"; done
----

Same for lvm:

[source,text]
----
# for command in vgscan vgchange; do ln -s lvm "bin/${command}"; done
----

Next creation of some basic device nodes, including the encrypted root device:

[source,text]
----
# cp -a /dev/console /dev/sda5 /dev/null /dev/random /dev/urandom dev && ln -s ../console dev/vc/0
----

Now for an init script, which will be loaded by the kernel, and handles all of the automation magic:

[source,text]
----
# nano init
----

[source,text]
----
#!/bin/sh

mount -t proc none /proc
CMDLINE='cat /proc/cmdline'

mount -t sysfs none /sys

#wait a little to avoid trailing kernel output
sleep 3

#rescue function in case something is going wrong
rescue_shell() {
    echo "Something went wrong. Dropping you to a shell."
    busybox --install -s
    exec /bin/sh
}

#dm-crypt
/bin/cryptsetup luksOpen /dev/sda5 encrypt || rescue_shell

#lvm
/bin/lvm vgchange -ay crypt || rescue_shell

#root filesystem
mount -r /dev/mapper/crypt-root /newroot || rescue_shell

#unmount pseudo FS
umount /sys
umount /proc

#root switch
exec /bin/busybox switch_root /newroot /sbin/init ${CMDLINE}
----

The permissions need to be adjusted:

[source,text]
----
# chmod a+x init
----

Now to create the initrd file:

[source,text]
----
# find . | cpio --quiet -o -H newc | gzip -9 > /boot/initrd-3.8.8-hardened
----

Note that the file is named that way because `grub2-mkconfig` which will be used in a moment recognizes this particular pattern and automates the entire config generation process. 

==== Bootloader ====

Before even starting make sure this is in `/etc/portage/make.conf`:

[source,text]
----
GRUB_PLATFORMS="efi-64"
----

Also mount the EFI partition, which in this case is `/dev/sda1`:

[source,text]
----
# mkdir /boot/efi && mount /dev/sda1 /boot/efi
----

Now emerge grub2 which provides excellent EFI boot support:

[source,text]
----
# emerge grub:2
----

Finally the actual setup process:

[source,text]
----
# grub2-install --target=x86_64-efi --efi-directory=/boot/efi --boot-directory=/boot/efi/EFI --bootloader-id=grub2 --recheck
Installation finished. No error reported.
----

If something goes weird here, be sure that `/boot/efi` is mounted, and target is spelled properly. Should that fail it would be best to ask for advice on forums/IRC/mailing list. Finally the bootloader configuration needs to be generated, which `grub2-mkconfig` handles:

[source,text]
----
# grub2-mkconfig -o /boot/efi/EFI/grub2/grub.cfg
----

[source,text]
----
# grub2-mkconfig -o /boot/efi/EFI/grub2/grub.cfg
Generating grub.cfg ...
Found linux image: /boot/vmlinuz-3.8.8-hardened
Found initrd image: /boot/initrd-3.8.8-hardened
Found linux image: /boot/vmlinuz-3.8.8-hardened.old
Found initrd image: /boot/initrd-3.8.8-hardened
done
----

Noticed how it picked up both the initrd and vmlinuz files, which produces the following configuration section in `/boot/efi/EFI/grub2/grub.cfg`:

[source,text]
----
menuentry 'Gentoo GNU/Linux' --class gentoo --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-simple-/dev/mapper/crypt-root' {
        load_video
        set gfxpayload=keep
        insmod gzio
        insmod part_gpt
        insmod ext2
        set root='hd0,gpt4'
        if [ x$feature_platform_search_hint = xy ]; then
          search --no-floppy --fs-uuid --set=root --hint-bios=hd0,gpt4 --hint-efi=hd0,gpt4 --hint-baremetal=ahci0,gpt4  01d8ad9b-0e43-4640-b3f5-7ecef704f59b
        else
          search --no-floppy --fs-uuid --set=root 01d8ad9b-0e43-4640-b3f5-7ecef704f59b
        fi
        echo    'Loading Linux 3.8.8-hardened ...'
        linux   /vmlinuz-3.8.8-hardened root=/dev/mapper/crypt-root ro  
        echo    'Loading initial ramdisk ...'
        initrd  /initrd-3.8.8-hardened
----

== Booting Into The New System ==

Now for the moment of truth, which is to boot into the new system! First exit the chroot:

[source,text]
----
(chroot) stuff initram # exit
exit
stuff ~ #
----

Be sure that there are not any open screen/tmux sessions open that might be in one of the `/mnt/gentoo` directories. If there is one, it will prevent umounting of the `/mnt/gentoo` directory. Now then to unmount everything:

[source,text]
----
# umount /mnt/gentoo/boot/efi
# umount /mnt/gentoo/boot
# umount /mnt/gentoo/proc
# umount -l /mnt/gentoo/sys
# umount -l /mnt/gentoo/dev
# umount /mnt/gentoo
----

Order is important here, as you cannot unmount a directory if there is something mounted in one of its subdirectories. Also the `-l` is used for cases where `--rbind` was passed to mount. Now all that's left is the reboot:

[source,text]
----
# reboot
----

Upon reboot you should be prompted with:

[source,text]
----
Enter passphrase for /dev/sda5:
----

Enter the passphrase here, and be sure to do it as soon as possible or driver loading will fail to proceed properly. Once everything has booted you will need to login as root. Next is to connect to the wifi access point of choice with network manager:

[source,text]
----
# nmcli dev list
----

Will give you a list of access point in case you can't remember the SSID off hand. Once the SSID is found then just:

[source,text]
----
# nmcli dev wifi connect <SSID> password <password>
----

From there it's recommended to delete that line from `~/.bash_history` for security purposes. Now to test the SSH connectivity:

[source,text]
----
# ssh root@<ip>
----

The SSH server fingerprint will differ from the so you will need to remove the entry from known hosts. Once the entry has been removed *physically walk over to the machine* and enter:

[source,text]
----
# ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub 
256 cc:22:b2:e1:9e:15:ce:77:bc:77:28:a7:e5:7a:c3:5c  root@inferno (ECDSA)
----

Now ssh to the machine and verify that the fingerprint maches:

[source,text]
----
$ ssh root@<ip>
The authenticity of host '<ip> (<ip>)' can't be established.
ECDSA key fingerprint is cc:22:b2:e1:9e:15:ce:77:bc:77:28:a7:e5:7a:c3:5c.
Are you sure you want to continue connecting (yes/no)? yes
----

The key matches okay so I continue to connect. If the key does not match *do not continue there is something seriously wrong ask for help on a forum*. 

== User Setup ==

Now to setup a standard user:

[source,text]
----
# useradd -m -G users,wheel,audio,video -s /bin/bash cwgem
# passwd cwgem
New password: 
Retype new password: 
passwd: password updated successfully
----

* users - Makes a general user
* wheel - Allows for `su` and used for `sudo` access
* audio - Allows for audio device access
* video - Want this for the iSight access
